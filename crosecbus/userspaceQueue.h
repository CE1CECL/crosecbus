#pragma once

NTSTATUS CrosECQueueInitialize(_In_ WDFDEVICE Device);

DEFINE_GUID(GUID_DEVINTERFACE_CrosEC, 0xd66bb4f8, 0x0a7a, 0x4f89, 0x90, 0x33, 0x79, 0x8a, 0xff, 0xa4, 0xf5, 0x38);
// {d66bb4f8-0a7a-4f89-9033-798affa4f538}

#define FILE_DEVICE_CROS_EMBEDDED_CONTROLLER 0x80EC

#define IOCTL_CROSEC_XCMD \
	CTL_CODE(FILE_DEVICE_CROS_EMBEDDED_CONTROLLER, 0x801, METHOD_BUFFERED, FILE_READ_DATA | FILE_WRITE_DATA)
#define IOCTL_CROSEC_RDMEM CTL_CODE(FILE_DEVICE_CROS_EMBEDDED_CONTROLLER, 0x802, METHOD_BUFFERED, FILE_READ_DATA)

#define CROSEC_CMD_MAX_REQUEST  0x100
#define CROSEC_CMD_MAX_RESPONSE 0x100
#define CROSEC_MEMMAP_SIZE      0xFF

#define CROSEC_STATUS_IN_PROGRESS ((NTSTATUS)0xE0EC0001)  // EC Command in progress
#define CROSEC_STATUS_UNAVAILABLE ((NTSTATUS)0xE0EC0002)  // EC not available

// Events
EVT_WDF_IO_QUEUE_IO_DEVICE_CONTROL CrosECEvtIoDeviceControl;
EVT_WDF_IO_QUEUE_IO_STOP CrosECEvtIoStop;

typedef struct _CROSEC_READMEM {
	ULONG offset;
	ULONG bytes;
	UCHAR buffer[CROSEC_MEMMAP_SIZE];
} *PCROSEC_READMEM, CROSEC_READMEM;